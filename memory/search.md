# Search Bar Implementation with Key Interception and Icon Navigation

## Problem

In a standard SwiftUI `TextField` on macOS, arrow keys are used to move the cursor within the text field. Our task was to intercept these key presses (left/right arrows) for navigating through filtered application icons, and also to intercept the Enter key to launch the selected application, while maintaining text input and filtering functionality.

## Solution: Combination of `NSTextField` and `NSViewRepresentable`

To achieve the necessary control over key behavior and integration with the native `NSTextField`, we used the `NSViewRepresentable` approach.

### 1. `CustomNSTextField.swift`

This is a custom class inheriting from `NSTextField`. It allows overriding native key behavior:

*   **Intercepting Enter**: The `performKeyEquivalent(with event: NSEvent)` method intercepts the Enter key press (keyCode 36). This calls the `onEnterKey?()` closure, and the method returns `true` to prevent default behavior (e.g., inserting a new line).
*   **Intercepting Arrows**: The `keyDown(with event: NSEvent)` method intercepts arrow key presses (keyCode 123, 124, 125, 126). This calls the `onArrowKey?(.direction)` closure, and the method returns `true` to prevent `NSTextField`'s default behavior (cursor movement).

```swift
import AppKit

class CustomNSTextField: NSTextField {
    var onArrowKey: ((ArrowKey) -> Void)?
    var onEnterKey: (() -> Void)?

    enum ArrowKey {
        case up, down, left, right
    }

    override func performKeyEquivalent(with event: NSEvent) -> Bool {
        if event.keyCode == 36 { // Enter key
            onEnterKey?()
            return true
        }
        return super.performKeyEquivalent(with: event)
    }

    override func keyDown(with event: NSEvent) {
        switch Int(event.keyCode) {
        case 126: // Up arrow
            onArrowKey?(.up)
            return
        case 125: // Down arrow
            onArrowKey?(.down)
            return
        case 123: // Left arrow
            onArrowKey?(.left)
            return
        case 124: // Right arrow
            onArrowKey?(.right)
            return
        default:
            super.keyDown(with: event)
        }
    }
}
```

### 2. `CustomTextField.swift`

This is a structure that implements the `NSViewRepresentable` protocol. It wraps `CustomNSTextField` and provides it as a SwiftUI `View`.

*   **`makeNSView`**: Creates an instance of `CustomNSTextField`, sets its delegate (`Coordinator`), and passes the `onArrowKey` and `onEnterKey` closures. It also configures the appearance (disables border, sets background, font, text color, and placeholder).
*   **`Coordinator`**: A nested class that acts as a delegate for `NSTextField`.
    *   `controlTextDidChange`: Updates the bound `text` when the text field's content changes.
    *   `control(_:textView:doCommandBy:)`: **Key method for arrow interception.** This delegate method is called to handle special commands, including those generated by arrow keys. By returning `true` after calling `onArrowKey`, we prevent `NSTextField`'s default behavior (cursor movement).
    *   `controlTextDidBeginEditing` / `controlTextDidEndEditing`: Used to track the text field's focus state via the `onFocusChange` closure.

```swift
import SwiftUI
import AppKit

struct CustomTextField: NSViewRepresentable {
    @Binding var text: String
    var onArrowKey: ((CustomNSTextField.ArrowKey) -> Void)?
    var onEnterKey: (() -> Void)?
    var onFocusChange: ((Bool) -> Void)?

    func makeNSView(context: Context) -> CustomNSTextField {
        let textField = CustomNSTextField()
        textField.delegate = context.coordinator
        textField.onArrowKey = onArrowKey
        textField.onEnterKey = onEnterKey
        textField.isBordered = false
        textField.focusRingType = .none
        textField.backgroundColor = .clear
        textField.font = .systemFont(ofSize: 36)
        textField.textColor = .white
        textField.placeholderString = "Search"

        NotificationCenter.default.addObserver(
            context.coordinator,
            selector: #selector(context.coordinator.controlTextDidBeginEditing(_:)),
            name: NSTextField.textDidBeginEditingNotification,
            object: textField
        )
        NotificationCenter.default.addObserver(
            context.coordinator,
            selector: #selector(context.coordinator.controlTextDidEndEditing(_:)),
            name: NSTextField.textDidEndEditingNotification,
            object: textField
        )

        return textField
    }

    func updateNSView(_ nsView: CustomNSTextField, context: Context) {
        if nsView.stringValue != text {
            nsView.stringValue = text
        }
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, NSTextFieldDelegate {
        let parent: CustomTextField

        init(_ parent: CustomTextField) {
            self.parent = parent
        }

        func controlTextDidChange(_ obj: Notification) {
            guard let textField = obj.object as? NSTextField else { return }
            parent.text = textField.stringValue
        }

        @objc func controlTextDidBeginEditing(_ obj: Notification) {
            parent.onFocusChange?(true)
        }

        @objc func controlTextDidEndEditing(_ obj: Notification) {
            parent.onFocusChange?(false)
        }

        func control(_ control: NSControl, textView: NSTextView, doCommandBy commandSelector: Selector) -> Bool {
            switch commandSelector {
            case #selector(NSResponder.moveLeft(_:)):
                parent.onArrowKey?(.left)
                return true
            case #selector(NSResponder.moveRight(_:)):
                parent.onArrowKey?(.right)
                return true
            case #selector(NSResponder.moveUp(_:)):
                parent.onArrowKey?(.up)
                return true
            case #selector(NSResponder.moveDown(_:)):
                parent.onArrowKey?(.down)
                return true
            default:
                return false
            }
        }
    }
}
```

### 3. Integration in `ContentView.swift`

In `ContentView.swift`, the standard `TextField` was replaced with `CustomTextField`.

*   **Selection State**: `@State private var selectedAppIndex: Int?` was added to track the index of the currently selected icon among the filtered applications.
*   **Arrow Handling**: In `CustomTextField`'s `onArrowKey` closure, `selectedAppIndex` is updated. When pressing left/right, the index decreases/increases, staying within the bounds of the `filteredApps` array.
*   **Enter Handling**: In `CustomTextField`'s `onEnterKey` closure, the selected application is launched (`NSWorkspace.shared.open`) and the Launchpad is terminated (`NSApplication.shared.terminate(nil)`).
*   **Reset Selection**: When `searchText` changes (i.e., on new filtering), `selectedAppIndex` is reset to `0` (the first item) or `nil` if the list is empty.
*   **Visual Highlight**: `AppIconView` now uses `selectedAppIndex` (in addition to `hoverId`) to apply the gray border and scaling effect, ensuring automatic selection of the first item and movement of the selection frame during navigation.
*   **Search Bar Styling**: `CustomTextField` is styled with `padding()`, `background(Color.black.opacity(0.25))`, `cornerRadius(12)`, and `overlay(RoundedRectangle(cornerRadius: 12).stroke(Color.white.opacity(0.3), lineWidth: 1))` to give it a pleasant bordered appearance.
*   **Focus Management**: `onFocusChange` is used to update `isSearchFocused`, allowing `KeyboardHandler` to correctly determine when not to intercept arrow keys for page navigation.

This implementation provides full control over the text field and key behavior, allowing for complex navigation and application launching logic while maintaining a native user experience.